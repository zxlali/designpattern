# designpattern


一天学习一种设计模式

设计模式的六大原则：

总原则：开闭原则，对修改关闭，对扩展开放。

1.     单一职责原则
       就一个类来，仅有一个引起它变化的原因，即一个接口或类只有一个职责，只负责一件事情。简单来说，一个类应该是一组相关性很高的函数、数据的封装

2.     里氏替换原则
所有引用基类的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应

3.     依赖倒置原则
面向接口编程，依赖抽象而不是具体。
依赖倒置原则指代了一种特定的解耦形式，使得高层的模块不依赖与低层次的模块的实现细节的目的
关键点：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节； 细节应该依赖抽象
每个类尽量实现接口或继承抽象类

4.     接口隔离原则
客户端不应该依赖它不需要的接口；类间的依赖关系应该建立在最小的接口上
接口隔离原则是对接口进行规范约束，包含4层含义：接口要尽量小，但是不能违反单一职责原则；接口要高内聚；定制服务，就是单独为一个个体提供优良的服务；接口的设计师有限度的

5.     迪米特法则（最少知道原则）
      一个对象应该对其他对象有最少的了解

6.     合成复用原则（多聚合，少继承）

 
设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

其实还有两类：并发型模式和线程池模式。

 
一、工厂模式

分类：简单工厂、工厂方法和抽象工厂。简单工厂是工厂方法的特例。

区别：

工厂方法：一个抽象产品类，可以派生出多个具体产品类，一个抽象工厂类可以派生出多个具体工厂类，每个具体工厂类负责生产一个具体产品。

抽象工厂：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类可以派生出多个具体工厂类，每个具体工厂类负责生产多个具体产品。
适用场景：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式

 

总之，工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。

 

 

二、责任链模式

责任链模式是一种对象的行为模式。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

抽象处理者角色(Handler:Approver):定义一个处理请求的接口，和一个后继连接(可选)

具体处理者角色(ConcreteHandler:President):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。

客户类(Client):向一个链上的具体处理者ConcreteHandler对象提交请求。



 

三、代理模式

定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用

 

ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。

RealSubject：真实主题角色，是实现抽象主题接口的类。

Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。

实现动态代理的关键技术是反射。

 

静态代理-采用聚合或继承的方式实现

动态代理-cglib JDK实现

cglib基于继承，JDK基于接口


 

四、适配器模式

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

需要适配的类（Adaptee）：需要适配的类或适配者类。

适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。



 

类适配器模式：通过继承实现

对象适配器模式：通过组合实现

接口适配器模式：通过抽象类实现

类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：

（1）想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。

（2）我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。

接口适配器使用场景：

（1）想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

 

五、外观模式

外观模式，一般用在子系统与访问之间，用于对访问屏蔽复杂的子系统调用，采用耳目一新的外观类提供的简单的调用方法，具体的实现由外观类去子系统调用。

 

适用场景

当我们访问的子系统拥有复杂额结构，内部调用繁杂，初接触者根本无从下手时，不凡由资深者为这个子系统设计一个外观类来供访问者使用，统一访问路径（集中到外观类中），将繁杂的调用结合起来形成一个总调用写到外观类中，之后访问者不用再繁杂的方法中寻找需要的方法进行调用，直接在外观类中找对应的方法进行调用即可。

 

六、         桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。



 

七、装饰器模式

动态地给一个对象添加一些额外的职责或者行为。就增加功能来说，Decorator模式相比生成子类更为灵活。



八、策略模式

将可变的部分从程序中抽象分离成算法接口，在该接口下分别封装一系列算法实现。并使他们可以相互替换，从而导致客户端程序独立于算法的改变。

策略模式中的设计原则：变化的抽象成接口；面向接口编程而不是面向实现编程。

 

这个模式涉及到三个角色：

●环境(Context)角色：持有一个Strategy的引用。

●抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。

●具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。



 

九、享元模式

顾名思义：共享元对象。如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用创建新的对象。

享元模式是为数不多的、只为提升系统性能而生的设计模式。它的主要作用就是复用大对象（重量级对象），以节省内存空间和对象创建时间。




十、模板方法
定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
优点：
封装不变部分，扩展可变部分：把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。
提取公共部分代码，便于维护。
行为由父类控制，子类实现。
适用场景：
多个子类有公有的方法，并且逻辑基本相同。
重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通 过钩子函数（见“模板方法模式的扩展”）约束其行为。
十一、原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。


原型模式的优点：
* 性能优良：原型模式是对内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时。
* 避免构造函数的约束。
* 原型模式的使用场景
资源优化场景：类初始化需要消耗非常多的资源。
* 性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限。
* 一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。
